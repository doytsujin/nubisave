""" should be used to distinguish between casesensitive files/directories 
i.e. a directory could be appended consisting of a hash and numbers for the upper case letters; pAth/FilE ->path/158HASH/file"""
180 dropbox api, architektur
40 fuse
50 - tests
40 tests
110 tests
120 io_api for dropbox
*** debugged directory creation; fixed problem with missing root "/" in dropbox_io_api
60 debugging path error
20 fixed problem with parsing modified date in test_io_api
20 logging
60 logging, tests 
60 tests
Mi
45 found time difference in test modified times: server time is different to local system	
40 fixed time difference problem but only for get_modified
Do
70 tests - fixed bug in get_directory_listing with return value and storing hash value in hashtable added cache for directory listings
*** reorganizing package structure, playing with git svn, committing to branch dropbox_api
Mo 
60
what happens if there is a system crash and cached data is not yet transfered?
cache decorator pattern vs strategy (caching dict)
Do
40
Fr
40 adding exceptions + tests for dropbox_io_api
*** adding exceptions + tests for dropbox_io_api and trying to refactor test_io_api
50 improved _test_is_dir; made get_metadata private method of dropbox_io_api; removed _test_get_metadat,  adding exceptions + tests for dropbox_io_api
*** got fusex to work
Mo
decorator pattern for caching, logging, path checking
Di
Added method store_fileobject to store interface
Need to add tests for store_fileobject?
So
30
40
Mo
45
Di
25




Regex for decorator generation from existing interface 
def ([^)]*)(self,? ?)([^)]*)\):\R        raise NotImplementedError\(\)  
def \1\2\3):\R        self.store.\1\3)

make decorators a file subclass 
implement error handling
implement chaching
implement concurrency
implement metadata:
implement thumbnails
file must not be larger than 300 MB
# hash - Optional. Listing return values include a hash representing the state of the directory's contents. If you provide this argument to the metadata call, you give the service an opportunity to respond with a "304 Not Modified" status code instead of a full (potentially very large) directory listing. This argument is ignored if the specified path is associated with a file or if list=false.
# list - Optional. The strings true and false are valid values. true is the default. If true, this call returns a list of metadata representations for the contents of the directory. If false, this call returns the metadata for the directory itself.
"%a, %d %b %Y %H:%M:%S %Z"
"Sat, 21 Aug 2010 22:31:20 +0000"

Efficiency

   1. Don't recursively troll the metadata to build your directory UI on startup. Instead, only get the directory the user is viewing, and do some caching so you don't have to ask constantly.
   2. Use the hash parameter to metadata with the last hash you had so that you can get a shorter list. What this does is give you a 304 if hash matches, and the contents again if the hash is different from what we have.
   3. Don't download anything until the user has actually asked for it, and then keep it around unless it's been updated. If you keep the hash we give you from the metadata for the file then you can see if you need to get it with another metadata call.

Version Numbers

Remember that <version> is replaced with our API version number, which is currently version 0 (zero). This means that your full URL will be: http://api.dropbox.com/0/oauth/request_token
Error handling

All errors are returned using standard HTTP error code syntax. For example, you should recognize a 404 error means, roughly, that the file you are trying to can't be found. If there is more information, the Dropbox API will include that info in the body of the return call in standard JSON format.
Standard Dropbox errors
507	"User over quota."
503	"too many requests".
5xx	"Server error"
Standard OAuth layer errors
401	Bad or expired token -> simply re-authenticate the user.
403	"wrong consumer token, bad nonce, expired timestamp, ..." fileop forbidden
Standard API layer errors
400	"Bad input parameter"
405	"Request method not expected (generally should be GET or POST)"
/token
400	Lacking mobile authentication permission.
401	Bad or expired token. This can happen if the user or the OAuth provider interrupted or revoked authorization. To fix, simply re-authenticate the user.
406	Too many file entries to return.
411	Length required. This typically returns when you attempt to upload over HTTP using chunked encoding. The Dropbox API currently does not support chunked transfer encoding.
403	A file or folder already exists at the location specified by the path.
For more information on error handling, please browse through the methods in the REST API. Specific error codes will be listed in every method where an error can be expected.
from cloudfusion.store.dropbox.file_decorator import NonclosingFile
import os, sys, stat,  time
from errno import ENOENT
from cloudfusion.fuse import FUSE, FuseOSError, Operations, LoggingMixIn
from cloudfusion.store.dropbox.dropbox_store import DropboxStore
import tempfile

# Specify what Fuse API use: 0.2
#fuse.fuse_python_api = (0, 2)

def zstat():
    now = time.time()
    st = {}
    st['st_mode'] = 0
    st['st_ino']  = 0
    st['st_dev']  = 0
    st['st_nlink']= 1
    st['st_uid']  = os.getuid()
    st['st_gid']  = os.getgid()
    st['st_size'] = 0
    st['st_atime']= now
    st['st_mtime']= now
    st['st_ctime']= now
    return st

class PyFuseBox(Operations):
    def __init__(self, path):
        self.root = path
        self.temp_file = None
        self.io_api = DropboxStore()
        self.f = open('fuselog', 'w')

        #io_api.store_file(file, root_dir)
    def getattr(self, path, fh=None):
        self.f.write( "getattr "+path)
        st = zstat()
        try:
            metadata = self.io_api._get_metadata(path)
        except: 
            raise FuseOSError(ENOENT)
        st['st_atime']= metadata['modified']
        st['st_mtime']= metadata['modified']
        st['st_ctime']= metadata['modified']
        if metadata['is_dir']:
            self.f.write( " isDir\n")
            st['st_mode'] = 0777 | stat.S_IFDIR
            st['st_nlink']=2
            st['st_size'] = 1
        else:
            self.f.write( " isFile\n")
            st['st_mode'] = 0777 | stat.S_IFREG
            st['st_size'] = metadata['bytes']
        return st
    
    def open(self, path, flags):
        self.f.write( "open "+path+"\n")
        self.temp_file = tempfile.SpooledTemporaryFile()
        if self.io_api.exists(path):
            file = self.io_api.get_file(path)
            self.temp_file.write(file.read())
            self.temp_file.seek(0)
        self.io_api.store_fileobject(self.temp_file,path)
        return 0
    
    def truncate(self, path, length, fh=None):
        self.f.write( "truncate %s to %s\n" % (path, length))
        self.io_api.delete(path)
        self.temp_file = tempfile.SpooledTemporaryFile()
        self.io_api.store_fileobject(self.temp_file,path)
        return 0
    
    def rmdir(self, path):
        self.f.write( "rmdir %s\n" % (path))
        self.io_api.delete(path)
        
    def mkdir(self, path, mode):
        self.f.write( "mkdir %s with mode: %s\n" % (path, str(mode)))
        self.io_api.create_directory(path)

    def statfs(self, path):
        """ This implementation should be looked at by a linux guru, since I have little experience concerning filesystems. """
        ret = {}
        ret['f_bsize'] = 4096 #Preferred file system block size.
        ret['f_bavail'] = int( self.io_api.get_free_space() / ret['f_bsize'] ) #Free blocks available to non-super user.
        ret['f_bfree'] = int( self.io_api.get_free_space() / ret['f_bsize'] ) #Total number of free blocks.
        ret['f_blocks'] = int( self.io_api.get_overall_space() / ret['f_bsize'] ) #Total number of blocks in the filesystem.
        ret['f_favail'] = 810280 #Free nodes available to non-super user -- not sure about this
        ret['f_ffree'] = ret['f_favail'] #Total number of free file nodes.
        ret['f_files'] = 810280 #Total number of file nodes -- not sure about this
        ret['f_flag'] = 4096 #Flags. System dependent: see statvfs() man page.
        ret['f_frsize'] = 4096 #Fundamental file system block size.
        ret['f_namemax'] = 255 #Maximum file name length.
        return ret
    
    def rename(self, old, new):
        self.f.write( "rename %s to %s\n" % (old, new))
        self.io_api.move(old, new)

    def create(self, path, mode):
        self.f.write( "create %s with mode %s\n" % (path, str(mode)))
        self.temp_file = tempfile.SpooledTemporaryFile()
        self.io_api.store_fileobject(self.temp_file, path)
        return 0
        """       self.files[path] = dict(st_mode=(S_IFREG | mode), st_nlink=1,
            st_size=0, st_ctime=time(), st_mtime=time(), st_atime=time())
        self.fd += 1
        return self.fd
    def truncate(self, path, length, fh=None):
        self.data[path] = self.data[path][:length]
        self.files[path]['st_size'] = length"""
    
    def unlink(self, path):
        self.f.write( "unlink %s\n" % path)
        self.io_api.delete(path)

    def read(self, path, size, offset, fh):
        self.f.write( "read %s bytes from %s at %s - fh %s\n" % (size, path, offset, fh))
        file = self.io_api.get_file(path)
        #file.seek(offset)
        return  file.read(size)

    def write(self, path, buf, offset, fh):
        self.f.write( "write %s ... from %s at %s - fh: %s\n" % (path, buf[0:10], offset, fh))
        self.temp_file = tempfile.SpooledTemporaryFile()
        file = self.io_api.get_file(path)
        self.temp_file.write(file.read())
        self.temp_file.seek(offset)
        self.temp_file.write(buf)
        self.temp_file.seek(0)
        self.io_api.store_fileobject(self.temp_file,path)
        return len(buf)
    
    def flush(self, path, fh):
        self.f.write( "flush %s - fh: %s\n" % (path, fh))
        #self.io_api.store_fileobject(fh,path)
        return 0
    
    def release(self, path, fh):
        self.f.write( "release %s - fh: %s\n" % (path, fh))
        #self.temp_file.close()
        return 0
       
    def readdir(self, path, fh):
        self.f.write( "readdir "+path+"\n")
        directories = self.io_api.get_directory_listing(path)
        #self.f.write( "readdir -> "+str(directories)+"\n")
        file_objects = [".", ".."]
        for file_object in directories:
            if file_object != "/":
                file_object = os.path.basename(file_object)
                file_objects.extend( [os.path.basename(file_object)] )
        return file_objects;

def main():
    if len(sys.argv) != 2:
        print 'usage: %s <mountpoint>' % sys.argv[0]
        exit(1)
    FUSE(PyFuseBox(sys.argv[1]), sys.argv[1], foreground=False, nothreads=True)
    
if __name__ == '__main__':
    main()


 